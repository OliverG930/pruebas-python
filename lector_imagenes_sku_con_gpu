import cv2
import pytesseract
import os
import re
import shutil
import easyocr
import numpy as np
import torch
import concurrent.futures
from pyzbar.pyzbar import decode, ZBarSymbol

# ==============================
# ğŸ§  CONFIGURACIÃ“N BASE
# ==============================
pytesseract.pytesseract.tesseract_cmd = r"C:\Program Files\Tesseract-OCR\tesseract.exe"


# ==============================
# ğŸ” DETECCIÃ“N DE GPU
# ==============================
def verificar_gpu():
    try:
        if torch.cuda.is_available():
            gpu_name = torch.cuda.get_device_name(0)
            gpu_memory = torch.cuda.get_device_properties(0).total_memory / 1e9
            print(f"ğŸ® GPU detectada: {gpu_name} ({gpu_memory:.1f} GB)")
            return True
        elif torch.backends.mps.is_available():
            print("ğŸ GPU Apple MPS detectada (Metal)")
            return True
        else:
            print("âŒ No se detectÃ³ GPU, se usarÃ¡ CPU")
            return False
    except:
        return False


# ==============================
# âš™ï¸ INICIALIZACIÃ“N EASY OCR
# ==============================
has_gpu = verificar_gpu()
try:
    reader = easyocr.Reader(['en', 'es'], gpu=has_gpu)
    print(f"âœ… EasyOCR inicializado correctamente (GPU={has_gpu})")
except Exception as e:
    print(f"âš ï¸ EasyOCR fallÃ³, se usarÃ¡ solo Tesseract: {e}")
    reader = None


# ==============================
# ğŸ§© FUNCIONES AUXILIARES
# ==============================
def corregir_errores_ocr(texto):
    mapa = {'o': '0', 'O': '0', 'Q': '0', 'D': '0', 'l': '1', 'I': '1', 'i': '1', '|': '1',
            'Z': '2', 'z': '2', 'S': '5', 's': '5', 'B': '8', 'g': '9', 'q': '9',
            ']': '1', '[': '1', 'Â£': '1', 'Â§': '5', 'T': '7', 't': '7'}
    return ''.join(mapa.get(c, c) for c in texto)


def es_sku_valido(sku):
    if len(sku) != 13 or not sku.isdigit():
        return False
    if len(set(sku)) < 5 or '0000' in sku:
        return False
    for patron in ['0123456789', '1234567890', '0000000000000', '1111111111111']:
        if patron in sku:
            return False
    return True


def leer_codigo_barras(imagen_path):
    """Intentar decodificar un cÃ³digo de barras real."""
    try:
        img = cv2.imread(imagen_path)
        if img is None:
            return None
        barcodes = decode(img, symbols=[ZBarSymbol.EAN13, ZBarSymbol.EAN8, ZBarSymbol.UPCA, ZBarSymbol.CODE128])
        for bc in barcodes:
            codigo = bc.data.decode("utf-8").strip()
            if codigo.isdigit() and len(codigo) in [12, 13]:
                if len(codigo) == 12:
                    codigo = "0" + codigo
                if es_sku_valido(codigo):
                    print(f"ğŸ“¦ CÃ³digo de barras detectado: {codigo}")
                    return codigo
        return None
    except Exception as e:
        print(f"âš ï¸ Error leyendo cÃ³digo de barras: {e}")
        return None


def buscar_sku_en_texto(texto):
    texto_corr = corregir_errores_ocr(texto)
    digitos = re.sub(r'\D', '', texto_corr)
    if len(digitos) == 13:
        return digitos
    patrones = [r'(\d{13})', r'(\d{12})', r'(\d{14})']
    for patron in patrones:
        for m in re.findall(patron, digitos):
            if len(m) == 13:
                return m
            elif len(m) == 12:
                return "0" + m
    return None


# ==============================
# ğŸ§® PROCESAMIENTO DE IMÃGENES
# ==============================
def preprocesar_imagen(imagen):
    gris = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    gris = cv2.fastNlMeansDenoising(gris)
    clahe = cv2.createCLAHE(clipLimit=2.5, tileGridSize=(8, 8))
    eq = clahe.apply(gris)
    _, bin_otsu = cv2.threshold(eq, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    _, bin_inv = cv2.threshold(eq, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    adapt = cv2.adaptiveThreshold(eq, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, 5)
    return [eq, bin_otsu, bin_inv, adapt]


def extraer_texto(imagen):
    textos = []
    if reader:
        try:
            res = reader.readtext(imagen, detail=1, paragraph=False)
            for _, txt, conf in res:
                if conf > 0.1 and txt.strip():
                    textos.append(txt.strip())
        except Exception:
            pass
    try:
        texto_tess = pytesseract.image_to_string(imagen, config='--psm 6 -c tessedit_char_whitelist=0123456789').strip()
        if texto_tess:
            textos.append(texto_tess)
    except:
        pass
    return textos


# ==============================
# ğŸ§  DETECCIÃ“N DE SKU (MULTIHILO)
# ==============================
def detectar_sku(imagen_path):
    sku = leer_codigo_barras(imagen_path)
    if sku:
        return sku
    img = cv2.imread(imagen_path)
    if img is None:
        return None

    versiones = preprocesar_imagen(img)
    for v in versiones:
        for texto in extraer_texto(v):
            sku = buscar_sku_en_texto(texto)
            if sku and es_sku_valido(sku):
                return sku
    return None


# ==============================
# ğŸš€ PROCESAMIENTO PRINCIPAL
# ==============================
def renombrar_imagenes_inteligente(carpeta):
    archivos = sorted([f for f in os.listdir(carpeta) if f.lower().endswith(('.jpg', '.jpeg', '.png'))])
    if len(archivos) % 2 != 0:
        print("âš ï¸ Advertencia: nÃºmero impar de imÃ¡genes.")
    pares = len(archivos) // 2
    print(f"ğŸ“ ImÃ¡genes encontradas: {len(archivos)} ({pares} pares)")

    carpeta_destino = os.path.join(carpeta, "Renombradas_Inteligentes")
    os.makedirs(carpeta_destino, exist_ok=True)

    skus_ok, skus_fail = 0, 0

    # Multihilo: procesar varios pares en paralelo
    with concurrent.futures.ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:
        futures = []
        for i in range(pares):
            img_principal = archivos[i * 2]
            img_codigo = archivos[i * 2 + 1]
            futures.append(executor.submit(procesar_par, carpeta, carpeta_destino, img_principal, img_codigo))

        for f in concurrent.futures.as_completed(futures):
            exito = f.result()
            if exito:
                skus_ok += 1
            else:
                skus_fail += 1

    print("\n" + "=" * 60)
    print(f"ğŸ“Š RESULTADOS:")
    print(f"âœ… SKUs detectados: {skus_ok}")
    print(f"âŒ Sin SKU: {skus_fail}")
    print(f"ğŸ“‚ Guardadas en: {carpeta_destino}")


def procesar_par(carpeta, destino, img_principal, img_codigo):
    ruta_principal = os.path.join(carpeta, img_principal)
    ruta_codigo = os.path.join(carpeta, img_codigo)
    print(f"\nğŸ” Procesando: {img_codigo}")
    sku = detectar_sku(ruta_codigo)
    if sku:
        nombre_seguro = re.sub(r'[^\w\-]', '_', sku)
        ruta_destino = os.path.join(destino, f"{nombre_seguro}.jpg")
        contador = 1
        while os.path.exists(ruta_destino):
            ruta_destino = os.path.join(destino, f"{nombre_seguro}_{contador}.jpg")
            contador += 1
        shutil.copy2(ruta_principal, ruta_destino)
        print(f"âœ… {img_principal} â†’ {os.path.basename(ruta_destino)}")
        return True
    else:
        print(f"âš ï¸ No se encontrÃ³ SKU en {img_codigo}")
        return False


# ==============================
# ğŸ MAIN
# ==============================
if __name__ == "__main__":
    print("=" * 60)
    print("ğŸ¯ SISTEMA OCR INTELIGENTE (Optimizado CPU/GPU + Multihilo)")
    print("=" * 60)
    carpeta = input("ğŸ“ Ingresa la ruta de la carpeta con las imÃ¡genes: ").strip('"')
    if not os.path.exists(carpeta):
        print("âŒ Carpeta no encontrada.")
    else:
        renombrar_imagenes_inteligente(carpeta)
